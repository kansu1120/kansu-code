{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"sample1":{
		"prefix":"c",
		"body":"cout << $1 << endl;$0"
	}
	"sample3":{
		"prefix":"all",
		"body":"$1.begin(),$1.end()$0"
	}
	"sample5":{
		"prefix":"vi",
		"body":"vector<int>"
	}
	"sample6":{
	"prefix":"vs",
	"body":"vector<string>"
	}
	"sample7":{
		"prefix":"vc",
		"body":"vector<char>"
	}
	"sample8":{
		"prefix":"vvi",
		"body":"vector<vector<int>>"
	}
	"sample9":{
		"prefix":"vvs",
		"body":"vector<vector<string>>"
	}	
	"sample10":{
		"prefix":"vvc",
		"body":"vector<vector<char>>"
	}
	"sample11":{
		"prefix":"i",
		"body":["int $1;  cin >> $1;","$0"]
	}	
	"sample12":{
		"prefix":"is",
		"body":["string $1;	 cin >> $1;","$0"]
	}	
	"sample13":{
		"prefix":"ic",
		"body":["char $1;  cin >> $1;","$0"]
	}		

  "sample15": {
    "prefix": "t",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <atcoder/all>",
      "using namespace atcoder;",
      "using namespace std;",
      "using ll = long long;",
      "#define rep(i , n) for(int i=0; i< (int)(n); i++)",
      "#define int long long",
      "const ll INF = 1e18;",
      "const int inf = 1e9;",
      "const int mod = 998244353;",
      "const int MOD = 1000000007;"
      "template<class T>",
      "void chmin(T& a, T b){ if(a > b) a = b; }",
      "template<class T>",
      "void chmax(T& a, T b){ if(a < b) a = b; }",
      "void yes(){cout << \"Yes\" << endl;}",
      "void no(){cout << \"No\" << endl;}",
      "using mint = modint998244353;",
      "int32_t main(){",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(nullptr);",
      "    $0",
      "}"
    ],
  }


	"sample16":{
		"prefix":"f",
		"body":"first"
	}
	"sample17":{
		"prefix":"se",
		"body":"second"
	}
	"sample18":{
		"prefix":"cy",
		"body":"cout << \"Yes\" << endl;"
	},
	"sample19":{
		"prefix":"cn",
		"body":"cout << \"No\" << endl;"
	}
	"sample20":{
		"prefix":"pi",
		"body":"pair<int,int>"
	}
	"sample21":{
		"prefix":"pl",
		"body":"pair<ll,ll>"
	}	
	"sample22":{
		"prefix":"vp",
		"body":"vector<pair<int,int>> "
	}
	"sample23":{
		"prefix":"vpl",
		"body":"vector<pair<ll,ll>> "
	}
	"sample24":{
		"prefix":"ce",
		"body":"cout << endl;"
	}
	"sample25":{
		"prefix":"rev",
		"body":"reverse($1.begin(),$1.end());"
	}
	"sample26":{
		"prefix":"sort",
		"body":"sort($1.begin(),$1.end());"
	}
	"sample27":{
		"prefix":"pb",
		"body":"push_back($1);"
	}
	"sample28":{
		"prefix":"iin",
		"body":"int n;  cin >> n;"
	}
	"sample29":{
		"prefix":"li",
		"body":"ll $1;	cin >> $1;$0"
	}
	"sample30":{
		"prefix":"im",
		"body":"int m;	cin >> m;"
	}
	"sample31":{
		"prefix":"vl",
		"body":"vector<ll>"
	}
	"sample32":{
		"prefix":"tmp",
		"body":["#include <bits/stdc++.h>","using namespace std;","using ll = long long;","#define rep(i , n) for(int i=0; i< (int)(n); i++)","const ll INF = 1e18;","const int inf = 1e9;","int main(){","$0","}"]
	}	
	"sample33":{
		"prefix":"pq",
		"body":"priority_queue<$0,vector<$0>,greater<$0>>"
	}
	"sample34":{
		"prefix":"nm",
		"body":"int n,m;	cin >> n >> m;"
	}
	"sample40":{
		"prefix":"hw",
		"body":"int h,w;	cin >> h >> w;"
	}
	"sample35":{
		"prefix":"iq",
		"body":"int q;	cin >> q;"
	}
"rmq segment tree": {
	"prefix": "rmq",
	"body": [
		"class segmenttree{",
		"public:",
		"    int siz = 1;",
		"    vector<int> v;",
		"    segmenttree (int n){",
		"        siz = 1;",
		"        while(siz < n)siz *= 2;",
		"        v.assign(2*siz,inf);",
		"    }",
		"    void update(int i, int x){",
		"        i += siz;",
		"        v[i] = x;",
		"        while(i > 1){",
		"            i /= 2;",
		"            v[i] = min(v[i*2],v[i*2+1]);",
		"        }",
		"    }",
		"    int query(int L, int R){   // 添字、L , R",
		"        int ans = inf;",
		"        function<void(int,int,int)> f = [&](int s,int l,int r){",
		"            if(l >= L && r <= R){",
		"                ans = min(ans,v[s]);",
		"                return;",
		"            }",
		"            if(r < L || l > R)return;",
		"            f(s*2,l,(l+r)/2);",
		"            f(s*2+1,(l+r)/2+1,r);",
		"            return;",
		"        };",
		"        f(1,0,siz-1);",
		"        return ans;",
		"    }",
		"};"
	]
}
"rsq segment tree": {
	"prefix": "rsq",
	"body": [
		"class segmenttree{",
		"public:",
		"    int siz = 1;",
		"    vector<int> v;",
		"    segmenttree (int n){",
		"        siz = 1;",
		"        while(siz < n)siz *= 2;",
		"        v.assign(2*siz,0);",
		"    }",
		"    void update(int i, int x){",
		"        i += siz;",
		"        v[i] = x;",
		"        while(i > 1){",
		"            i /= 2;",
		"            v[i] = v[i*2] + v[i*2+1];",
		"        }",
		"    }",
		"    int query(int L, int R){   // 添字、L , R",
		"        int ans = 0;",
		"        function<void(int,int,int)> f = [&](int s,int l,int r){",
		"            if(l >= L && r <= R){",
		"                ans += v[s];",
		"                return;",
		"            }",
		"            if(r < L || l > R)return;",
		"            f(s*2,l,(l+r)/2);",
		"            f(s*2+1,(l+r)/2+1,r);",
		"            return;",
		"        };",
		"        f(1,0,siz-1);",
		"        return ans;",
		"    }",
		"    int pos(int p){",
		"        return query(p,p);",
		"    }",
		"};"
	]
}
	"sample36":{
		"prefix":"vb",
		"body":"vector<bool> "
	}

  "kansu_library_all": {
    "prefix": "kansu",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <atcoder/all>",
      "using namespace atcoder;",
      "using namespace std;",
      "using ll = long long;",
      "#define rep(i,n) for(int i = 0; i < (int)(n); i++)",
      "#define int long long",
      "const ll INF = 1e18;",
      "const int inf = 1e9;",
      "",
      "// ===== RMaxQ =====",
      "class segmenttree_max{",
      "public:",
      "    int siz = 1;",
      "    vector<int> v;",
      "    segmenttree_max(int n){",
      "        while(siz < n){",
      "            siz *= 2;",
      "        }",
      "        v.assign(2*siz, -inf);",
      "    }",
      "    void update(int i,int x){",
      "        i += siz;",
      "        v[i] = x;",
      "        while(i > 1){",
      "            i /= 2;",
      "            v[i] = max(v[i*2], v[i*2+1]);",
      "        }",
      "    }",
      "    int query(int L,int R){",
      "        int ans = -inf;",
      "        function<void(int,int,int)> f = [&](int s,int l,int r){",
      "            if(l >= L && r <= R){",
      "                ans = max(ans, v[s]);",
      "                return;",
      "            }",
      "            if(r < L || l > R) return;",
      "            f(s*2, l, (l+r)/2);",
      "            f(s*2+1, (l+r)/2+1, r);",
      "        };",
      "        f(1, 0, siz-1);",
      "        return ans;",
      "    }",
      "};",
      "",
      "// ===== RMinQ =====",
      "class segmenttree_min{",
      "public:",
      "    int siz = 1;",
      "    vector<int> v;",
      "    segmenttree_min(int n){",
      "        while(siz < n){",
      "            siz *= 2;",
      "        }",
      "        v.assign(2*siz, inf);",
      "    }",
      "    void update(int i,int x){",
      "        i += siz;",
      "        v[i] = x;",
      "        while(i > 1){",
      "            i /= 2;",
      "            v[i] = min(v[i*2], v[i*2+1]);",
      "        }",
      "    }",
      "    int query(int L,int R){",
      "        int ans = inf;",
      "        function<void(int,int,int)> f = [&](int s,int l,int r){",
      "            if(l >= L && r <= R){",
      "                ans = min(ans, v[s]);",
      "                return;",
      "            }",
      "            if(r < L || l > R) return;",
      "            f(s*2, l, (l+r)/2);",
      "            f(s*2+1, (l+r)/2+1, r);",
      "        };",
      "        f(1, 0, siz-1);",
      "        return ans;",
      "    }",
      "};",
      "",
      "// ===== RSumQ =====",
      "class segmenttree_sum{",
      "public:",
      "    int siz = 1;",
      "    vector<int> v;",
      "    segmenttree_sum(int n){",
      "        while(siz < n){",
      "            siz *= 2;",
      "        }",
      "        v.assign(2*siz, 0);",
      "    }",
      "    void update(int i,int x){",
      "        i += siz;",
      "        v[i] = x;",
      "        while(i > 1){",
      "            i /= 2;",
      "            v[i] = v[i*2] + v[i*2+1];",
      "        }",
      "    }",
      "    int query(int L,int R){",
      "        int ans = 0;",
      "        function<void(int,int,int)> f = [&](int s,int l,int r){",
      "            if(l >= L && r <= R){",
      "                ans += v[s];",
      "                return;",
      "            }",
      "            if(r < L || l > R) return;",
      "            f(s*2, l, (l+r)/2);",
      "            f(s*2+1, (l+r)/2+1, r);",
      "        };",
      "        f(1, 0, siz-1);",
      "        return ans;",
      "    }",
      "};",
      "",
      "// ===== Run Length Encoding =====",
      "vector<pair<int,char>> r(string s){",
      "    vector<pair<int,char>> ans;",
      "    for(int i = 0; i < (int)s.size(); i++){",
      "        if(ans.empty() || ans.back().second != s[i]){",
      "            ans.push_back({1, s[i]});",
      "        }else{",
      "            ans.back().first++;",
      "        }",
      "    }",
      "    return ans;",
      "}",
      "",
      "// ===== Eratosthenes =====",
      "vector<int> p(int n){",
      "    vector<bool> ok(n+1, true);",
      "    ok[0] = ok[1] = false;",
      "    for(int i = 2; i*i <= n; i++){",
      "        if(ok[i]){",
      "            for(int j = i*i; j <= n; j += i){",
      "                ok[j] = false;",
      "            }",
      "        }",
      "    }",
      "    vector<int> ans;",
      "    for(int i = 0; i <= n; i++){",
      "        if(ok[i]) ans.push_back(i);",
      "    }",
      "    return ans;",
      "}",
      "",
      "// ===== SCC =====",
      "vector<vector<int>> scc(int n,const vector<vector<int>>& v){",
      "    vector<vector<int>> rv(n);",
      "    for(int i = 0; i < n; i++){",
      "        for(int to : v[i]){",
      "            rv[to].push_back(i);",
      "        }",
      "    }",
      "    vector<int> order;",
      "    vector<bool> used(n, false);",
      "    function<void(int)> dfs = [&](int x){",
      "        used[x] = true;",
      "        for(int to : v[x]){",
      "            if(!used[to]) dfs(to);",
      "        }",
      "        order.push_back(x);",
      "    };",
      "    for(int i = 0; i < n; i++){",
      "        if(!used[i]) dfs(i);",
      "    }",
      "    vector<vector<int>> res;",
      "    used.assign(n, false);",
      "    for(int i = n-1; i >= 0; i--){",
      "        int x = order[i];",
      "        if(used[x]) continue;",
      "        vector<int> comp;",
      "        function<void(int)> rdfs = [&](int y){",
      "            used[y] = true;",
      "            comp.push_back(y);",
      "            for(int to : rv[y]){",
      "                if(!used[to]) rdfs(to);",
      "            }",
      "        };",
      "        rdfs(x);",
      "        res.push_back(comp);",
      "    }",
      "    return res;",
      "}",
      "",
      "// ===== Lazy Segment Tree (range assign, range max) =====",
      "class lst{",
      "public:",
      "    vector<int> seg,lazy;",
      "    vector<bool> d;",
      "    int siz = 1;",
      "    lst(int n,int x){",
      "        while(siz < n){",
      "            siz *= 2;",
      "        }",
      "        seg.assign(2*siz, x);",
      "        lazy.assign(2*siz, 0);",
      "        d.assign(2*siz, false);",
      "    }",
      "    void push(int p){",
      "        if(!d[p]) return;",
      "        seg[p] = lazy[p];",
      "        if(p < siz){",
      "            lazy[p*2] = lazy[p*2+1] = lazy[p];",
      "            d[p*2] = d[p*2+1] = true;",
      "        }",
      "        d[p] = false;",
      "    }",
      "    void range_assign(int l,int r,int x){",
      "        range_assign(l,r,x,1,0,siz);",
      "    }",
      "    int range_max(int l,int r){",
      "        return range_max(l,r,1,0,siz);",
      "    }",
      "private:",
      "    void range_assign(int l,int r,int x,int p,int a,int b){",
      "        push(p);",
      "        if(r <= a || b <= l) return;",
      "        if(l <= a && b <= r){",
      "            lazy[p] = x;",
      "            d[p] = true;",
      "            push(p);",
      "            return;",
      "        }",
      "        int m = (a+b)/2;",
      "        range_assign(l,r,x,p*2,a,m);",
      "        range_assign(l,r,x,p*2+1,m,b);",
      "        seg[p] = max(seg[p*2], seg[p*2+1]);",
      "    }",
      "    int range_max(int l,int r,int p,int a,int b){",
      "        push(p);",
      "        if(r <= a || b <= l) return -inf;",
      "        if(l <= a && b <= r) return seg[p];",
      "        int m = (a+b)/2;",
      "        return max(range_max(l,r,p*2,a,m), range_max(l,r,p*2+1,m,b));",
      "    }",
      "};",
      "",
      "int32_t main(){",
	  "",
      "}"
    ],
  }
}


